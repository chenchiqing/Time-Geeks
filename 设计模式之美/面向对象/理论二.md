# 05 封装、继承、抽象、多态分别可以解决哪些编程问题？
## 封装（Encapsulation）
* 数据访问保护或者说信息隐藏。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息和数据
* 需要编程语言本身提供一定的语法机制（访问控制权限）来支持

### 简化版的虚拟钱包

        public class Wallet {
        private String id;
        private long createTime;
        private BigDecimal balance;
        private long balanceLastModifiedTime;
        // ...省略其他属性...

        public Wallet() {
            this.id = IdGenerator.getInstance().generate();
            this.createTime = System.currentTimeMillis();
            this.balance = BigDecimal.ZERO;
            this.balanceLastModifiedTime = System.currentTimeMillis();
        }

        // 注意：下面对get方法做了代码折叠，是为了减少代码所占文章的篇幅
        public String getId() { return this.id; }
        public long getCreateTime() { return this.createTime; }
        public BigDecimal getBalance() { return this.balance; }
        public long getBalanceLastModifiedTime() { return this.balanceLastModifiedTime;  }

        public void increaseBalance(BigDecimal increasedAmount) {
            if (increasedAmount.compareTo(BigDecimal.ZERO) < 0) {
            throw new InvalidAmountException("...");
            }
            this.balance.add(increasedAmount);
            this.balanceLastModifiedTime = System.currentTimeMillis();
        }

        public void decreaseBalance(BigDecimal decreasedAmount) {
            if (decreasedAmount.compareTo(BigDecimal.ZERO) < 0) {
            throw new InvalidAmountException("...");
            }
            if (decreasedAmount.compareTo(this.balance) > 0) {
            throw new InsufficientAmountException("...");
            }
            this.balance.subtract(decreasedAmount);
            this.balanceLastModifiedTime = System.currentTimeMillis();
        }
        }

钱包共四个属性，包括确定的唯一ID和创建时间createTime；以及钱包余额balance和最后一次交易的时间balanceLastModifiedTime。

### 封装的意义
* 如果不对类中属性做限制，那任何代码都可以访问、修改类中的属性，虽然很灵活，但是会严重影响到代码的可读性、可维护性
* 提高类的易用性。只暴露少数几个必要的方法给调用者使用，他们不需要了解背后的业务细节，减少用错的概率

## 抽象
