# 05 封装、继承、抽象、多态分别可以解决哪些编程问题？
## 封装（Encapsulation）
* 数据访问保护或者说信息隐藏。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息和数据
* 需要编程语言本身提供一定的语法机制（访问控制权限）来支持

### 简化版的虚拟钱包

        public class Wallet {
        private String id;
        private long createTime;
        private BigDecimal balance;
        private long balanceLastModifiedTime;
        // ...省略其他属性...

        public Wallet() {
            this.id = IdGenerator.getInstance().generate();
            this.createTime = System.currentTimeMillis();
            this.balance = BigDecimal.ZERO;
            this.balanceLastModifiedTime = System.currentTimeMillis();
        }

        // 注意：下面对get方法做了代码折叠，是为了减少代码所占文章的篇幅
        public String getId() { return this.id; }
        public long getCreateTime() { return this.createTime; }
        public BigDecimal getBalance() { return this.balance; }
        public long getBalanceLastModifiedTime() { return this.balanceLastModifiedTime;  }

        public void increaseBalance(BigDecimal increasedAmount) {
            if (increasedAmount.compareTo(BigDecimal.ZERO) < 0) {
            throw new InvalidAmountException("...");
            }
            this.balance.add(increasedAmount);
            this.balanceLastModifiedTime = System.currentTimeMillis();
        }

        public void decreaseBalance(BigDecimal decreasedAmount) {
            if (decreasedAmount.compareTo(BigDecimal.ZERO) < 0) {
            throw new InvalidAmountException("...");
            }
            if (decreasedAmount.compareTo(this.balance) > 0) {
            throw new InsufficientAmountException("...");
            }
            this.balance.subtract(decreasedAmount);
            this.balanceLastModifiedTime = System.currentTimeMillis();
        }
        }

钱包共四个属性，包括确定的唯一ID和创建时间createTime；以及钱包余额balance和最后一次交易的时间balanceLastModifiedTime。

### 封装的意义
* 如果不对类中属性做限制，那任何代码都可以访问、修改类中的属性，虽然很灵活，但是会严重影响到代码的可读性、可维护性
* 提高类的易用性。只暴露少数几个必要的方法给调用者使用，他们不需要了解背后的业务细节，减少用错的概率
---------------
## 抽象（）
* 隐藏方法的具体实现，让调用者只需要关心方法提供了那些功能，不需要知道这些功能如何实现
* 最常见的函数就是抽象的一种体现

### 图片存储
        public interface IPictureStorage {
        void savePicture(Picture picture);
        Image getPicture(String pictureId);
        void deletePicture(String pictureId);
        void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo);
        }

        public class PictureStorage implements IPictureStorage {
        // ...省略其他属性...
        @Override
        public void savePicture(Picture picture) { ... }
        @Override
        public Image getPicture(String pictureId) { ... }
        @Override
        public void deletePicture(String pictureId) { ... }
        @Override
        public void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo) { ... }
        }
为class PictureStorage抽象出一个接口 interface IPictureStotage，使用图片存储功能时只需要去了解该接口暴露的方法就行，无需查看类中的具体实现

### 抽象的意义
* 只关注功能点不关注实现的设计思路，有利于过滤掉很多非必要的信息，帮助我们将注意力集中到更重要的事情上去
* 定义方法时，不要在方法定义中暴露太多的细节，避免后续业务变动，造成大量的修改，违背开闭原则（开放拓展，关闭修改）
------------

## 继承（Inheritance）
* 用来表示类之间的is-a关系，分为单继承（一个子继承一个父类）和多继承（一个子继承多个父类）
* 多继承容易造成代码逻辑和业务逻辑的混乱。比如两个父类具有相同的属性和方法，那么子类调用的究竟是那个？
* 继承关系可以实现代码复用（可以更多的考虑组合）
-----------

## 多态（Polymorphism）